

# Python的垃圾回收机制

上次研究了下python中的赋值、浅拷贝、深拷贝，这次看看python的垃圾回收机制。

来源：

https://zhuanlan.zhihu.com/p/83251959，这个示意图比较多，但有一点错误，第三、四个图中的`link2`应该在右边

http://www.zhangdongshengtech.com/article-detials/177



## 引用计数

Python中，主要通过**引用计数（Reference Counting）**进行垃圾回收。

```c
typedef struct_object {
 int ob_refcnt;
 struct_typeobject *ob_type;
} PyObject;
```

在Python中每一个对象的核心就是一个结构体`PyObject`，它的内部有一个引用计数器`ob_refcnt`。程序在运行的过程中会实时的更新`ob_refcnt`的值，来反映引用当前对象的名称数量。当某对象的引用计数值为0,那么它的内存就会被立即释放掉。

以下情况是导致引用计数加一的情况:

- 对象被创建，例如a=2
- 对象被引用，b=a
- 对象被作为参数，传入到一个函数中
- 对象作为一个元素，存储在容器中

下面的情况则会导致引用计数减一:

- 对象别名被显示销毁 del
- 对象别名被赋予新的对象
- 一个对象离开他的作用域
- 对象所在的容器被销毁或者是从容器中删除对象

我们还可以通过sys包中的`getrefcount()`来获取一个名称所引用的对象当前的引用计数(注意，这里`getrefcount()`本身会使得引用计数加一)

```python
sys.getrefcount(a)

# python会缓存一些小整数和短字符串，所以引用并不会为1
>>> a = 2
>>> sys.getrefcount(a)
91
>>> b = a
>>> sys.getrefcount(a)
92
>>> del b
>>> sys.getrefcount(a)
91
>>> sys.getrefcount(1)
134
>>> sys.getrefcount(0)
236
>>> sys.getrefcount(2)
93

# 对于这样的可变对象，python没办法预先存在内存中
>>> s = [1,2,3]
>>> sys.getrefcount([1,2,3])
1
>>> sys.getrefcount(s)
2
# s引用一次，getrefcount()又引用一次，所以是2
>>>

```



## 分代回收

**`gc.get_threshold()`**

分代回收是基于这样的一个统计事实，**对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。**

python中，一共分了三代，可以使用`gc.get_threshold() `来获得每一代规定的数量，这个数值为(700,10,10)

当你创建一个对象后，它首先被放入到一代中，如果在一次一代的检查中存活下来，则放入二代，同理，如果在一次二代的检查中存活下来，则放入三代。

那么这个700，10，10 是怎么调节垃圾回收的频率呢？

首先，要理解第一个返回值，它表示从上一次垃圾回到现在，分配内存的数目减去释放内存的数目，如果这个数值到了700，那么就对第一代垃圾对象进行回收，并且第二个参数加1，当第二个参数增加到10的时候，对第一代和第二代垃圾对象进行回收，且第三个参数加1，当第三个参数为10的时候，三代都回收，这里借用一下别人文章里的一段（原文地址：http://www.jb51.net/article/79306.htm）

假设阀值是(700,10,10)：

- 当计数器从(699,3,0)增加到(700,3,0)，`gc`模块就会执行`gc.collect(0)`,即检查一代对象的垃圾，并重置计数器为(0,4,0)
- 当计数器从(699,9,0)增加到(700,9,0)，`gc`模块就会执行`gc.collect(1)`,即检查一、二代对象的垃圾，并重置计数器为(0,0,1)
- 当计数器从(699,9,9)增加到(700,9,9)，`gc`模块就会执行`gc.collect(2)`,即检查一、二、三代对象的垃圾，并重置计数器为(0,0,0)

 

## 循环引用

如果两个对象彼此互相引用，那么他们的引用计数就是1，而当python通过引用计数进行垃圾回收时，将无法回收他们



## 标记-清除

Python采用了**“标记-清除”(Mark and Sweep)**算法，解决容器对象可能产生的循环引用问题。(注意，只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列)

跟其名称一样，该算法在进行垃圾回收时分成了两步，分别是：

- A）标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达；
- B）清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。

（1） 将所有对象标记为白色

（2） 找到那些不能被回收的对象，标记为黑色，表示为有效对象

（3） 将有效对象的引用标记为灰色，表示对象可达

（4） 检查完灰色对象的引用后，将灰色对象标记为黑色

（5） 重复以上步骤，直到没有灰色对象为止，剩下的白色对象就是需要被清除的对象



总体来说，在Python中，主要通过`引用计数`进行垃圾回收；通过 `标记-清除 `解决容器对象可能产生的循环引用问题；通过` 分代回收`以空间换时间的方法提高垃圾回收效率。