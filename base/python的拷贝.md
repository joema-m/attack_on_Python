文字部分参考：https://zhuanlan.zhihu.com/p/54011712

## 0. 概念

首先明确几个概念

- 变量：是一个系统表的元素，拥有指向对象的连接空间

- 对象：被分配的一块内存，存储其所代表的值

- 引用：是自动形成的从变量到对象的指针

- 类型：属于对象，而非变量

- 不可变对象：一旦创建就不可修改的对象，包括字符串、元组、数值类型

  > 该对象所指向的内存中的值不能被改变。当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。

- 可变对象：可以修改的对象，包括列表、字典、集合

  > 该对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的地址，通俗点说就是原地改变。



```python
a = 'python'
```

Python解释器干的事情：

> 创建变量a
>
> 创建一个对象(分配一块内存)，来存储值 'python' 
>
> 将变量与对象，通过指针连接起来，从变量到对象的连接称之为引用(变量引用对象)



## 1..赋值、浅拷贝、深拷贝

**1.赋值: 只是复制了新对象的引用，不会开辟新的内存空间。**



**2.浅拷贝: 创建新对象，其内容是原对象的引用。**

> 1）当浅复制的值是不可变对象（字符串、元组、数值类型）时和“赋值”的情况一样，对象的id值*（id()函数用于获取对象的内存地址）*与浅复制原来的值相同。
>
> 2）当浅复制的值是可变对象（列表、字典、集合）时会产生一个“不是那么独立的对象”存在。有两种情况：
>
> > 第一种情况：复制的对象中无复杂子对象，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。
> >
> > 第二种情况：复制的对象中有复杂子对象（例如列表中的一个子元素是一个列表），如果不改变其中复杂子对象，浅复制的值改变并不会影响原来的值。 但是改变原来的值中的复杂子对象的值会影响浅复制的值。



**3.深拷贝：和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。深拷贝出来的对象是一个全新的对象，不再与原来的对象有任何关联。**



## 2.验证

### 2.1不可变对象

```python
# CPython 中id() 函数用于获取对象的内存地址
# 不可变对象 例如 string
>>> s = 'hello'
>>> copy_s = s
# 此时两者的内存地址是相同的
>>> id(s)
1762477241456
>>> id(copy_s)
1762477241456
# 但是改变值后，内存地址也就改变了
>>> copy_s = copy_s + ' world'
>>> id(copy_s)
1762477138096
>>> copy_s
'hello world'
>>> id(s)
1762477241456

# 使用copy.copy 与 copy.deepcopy
>>> cs = copy.copy(s)
>>> id(cs)
1762477241456
>>> ds = copy.deepcopy(s)
>>> id(ds)
1762477241456
# 地址仍然不变，即全部指向同一块内存
```



### 2.2可变对象

```python
# 可变对象 例如 list
>>> n = [1,2,3,4,5]
>>> copy_n = n
>>> id(n)
1762477140808
>>> copy_n.append(6)
>>> n
[1, 2, 3, 4, 5, 6]
>>> copy_n
[1, 2, 3, 4, 5, 6]
>>> id(n)
1762477140808
>>> id(copy_n)
1762477140808
>>> copy_copy_n = copy_n
>>> id(copy_copy_n)
1762477140808
# 可以看出，copy_n、n都指向同一块内存，修改一个，两个同时变化

# 但是如果对list切片，情况就不一样了
>>> split_n = n[:]
>>> id(split_n)
1762477376712
# 重新申请了一块内存，将n的所有元素复制进去

# 使用copy.copy 与 copy.deepcopy
>>> cc = copy.copy(n)
>>> id(cc)
1762477405576
>>> dd = copy.deepcopy(n)
>>> id(dd)
1762477090504
# 可以看出，两者地址都变了，n,cc,dd指向不同的地址，互不影响
```



### 2.3复杂可变对象的浅拷贝与深拷贝

```python
>>> comp = [1,2,3,[4,5,6]]
>>> id(comp)
1762477268936
>>> id(comp[3])
1762477267976
# 补充一下，对于一些小的数值、字符，python会将其预先存到内存中
# 向下面 comp[0] comp[1]地址之间只相差32，即python中int的位数
>>> id(comp[0])
140716619964816
>>> id(comp[1])
140716619964848
>>> id(comp[3])
1762477267976
>>> co_comp = copy.copy(comp)
>>> co_comp[3]
[4, 5, 6]
>>> id(co_comp[3])
1762477267976
>>> co_comp[3].append(100)
>>> co_comp
[1, 2, 3, [4, 5, 6, 100]]
>>> comp
[1, 2, 3, [4, 5, 6, 100]]
# 对于浅拷贝，被拷贝对象中的子对象地址仍相同，即还是引用
>>> de_co_comp = copy.deepcopy(comp)
>>> id(de_co_comp[3])
1762477191048
# 深拷贝就不一样了
```



## 3.扩展

### python函数的参数传递是传值还是引用？

原理是一样的，对于不可变对象，函数参数传递时值传递；对于可变对象，则是引用

```python
# 不可变对象
>>> def fun(num):
...     num = -1
...
>>> a = 10
>>> fun(a)
>>> a
10

# 可变对象
>>> def fun(list):
...     list.append('aaa')
...
>>> s = [1,2,3]
>>> fun(s)
>>> s
[1, 2, 3, 'aaa']
```

### 垃圾回收机制

另外，有必要了解一下python的垃圾回收机制。

